#include "Common.h"
#include <Jolt/Physics/SoftBody/SoftBodyContactListener.h>
#include <nanobind/trampoline.h>
#include <Jolt/Physics/Body/Body.h>
#include <Jolt/Physics/SoftBody/SoftBodyManifold.h>

class PySoftBodyContactListener : public SoftBodyContactListener {
  public:
    NB_TRAMPOLINE(SoftBodyContactListener, 2);

    ~PySoftBodyContactListener() override {
    }

    SoftBodyValidateResult OnSoftBodyContactValidate(const Body &inSoftBody,
                                                     const Body &inOtherBody,
                                                     SoftBodyContactSettings &ioSettings) override {
        NB_OVERRIDE_NAME(
            "on_soft_body_contact_validate",
            OnSoftBodyContactValidate,
            inSoftBody,
            inOtherBody,
            ioSettings);
    }

    void OnSoftBodyContactAdded(const Body &inSoftBody, const SoftBodyManifold &inManifold) override {
        NB_OVERRIDE_NAME(
            "on_soft_body_contact_added",
            OnSoftBodyContactAdded,
            inSoftBody,
            inManifold);
    }
};

void BindSoftBodyContactListener(nb::module_ &m) {
    nb::enum_<SoftBodyValidateResult>(m, "SoftBodyValidateResult",
        "Return value for the OnSoftBodyContactValidate callback. Determines if the contact will be processed or not.")
        .value("ACCEPT_CONTACT", SoftBodyValidateResult::AcceptContact,
            "Accept this contact")
        .value("REJECT_CONTACT", SoftBodyValidateResult::RejectContact,
            "Reject this contact");
    nb::class_<SoftBodyContactSettings> softBodyContactSettingsCls(m, "SoftBodyContactSettings",
        "Contact settings for a soft body contact.\n"
        "The values are filled in with their defaults by the system so the callback doesn't need to modify anything, but it can if it wants to.");
    softBodyContactSettingsCls
        .def_rw("inv_mass_scale1", &SoftBodyContactSettings::mInvMassScale1,
            "Scale factor for the inverse mass of the soft body (0 = infinite mass, 1 = use original mass, 2 = body has half the mass). For the same contact pair, you should strive to keep the value the same over time.")
        .def_rw("inv_mass_scale2", &SoftBodyContactSettings::mInvMassScale2,
            "Scale factor for the inverse mass of the other body (0 = infinite mass, 1 = use original mass, 2 = body has half the mass). For the same contact pair, you should strive to keep the value the same over time.")
        .def_rw("inv_inertia_scale2", &SoftBodyContactSettings::mInvInertiaScale2,
            "Scale factor for the inverse inertia of the other body (usually same as mInvMassScale2)")
        .def_rw("is_sensor", &SoftBodyContactSettings::mIsSensor,
            "If the contact should be treated as a sensor vs body contact (no collision response)");

    nb::class_<SoftBodyContactListener> softBodyContactListenerCls(m, "SoftBodyContactListener",
        "A listener class that receives collision contact events for soft bodies against rigid bodies.\n"
        "It can be registered with the PhysicsSystem.");
    softBodyContactListenerCls
        .def("on_soft_body_contact_validate", &SoftBodyContactListener::OnSoftBodyContactValidate, "soft_body"_a, "other_body"_a, "settings"_a,
            "Called whenever the soft body's aabox overlaps with another body's aabox (so receiving this callback doesn't tell if any of the vertices will collide).\n"
            "This callback can be used to change the behavior of the collision response for all vertices in the soft body or to completely reject the contact.\n"
            "Note that this callback is called when all bodies are locked, so don't use any locking functions!.\n"
            "Args:\n"
            "    soft_body (Body): The soft body that collided. It is safe to access this as the soft body is only updated on the current thread.\n"
            "    other_body (Body): The other body that collided. Note that accessing the position/orientation/velocity of inOtherBody may result in a race condition as other threads may be modifying the body at the same time.\n"
            "    settings (SoftBodyContactSettings): The settings for all contact points that are generated by this collision.\n"
            "Returns:\n"
            "    SoftBodyValidateResult: Whether the contact should be processed or not.")
        .def("on_soft_body_contact_added", &SoftBodyContactListener::OnSoftBodyContactAdded, "soft_body"_a, "manifold"_a,
            "Called after all contact points for a soft body have been handled. You only receive one callback per body pair per simulation step and can use inManifold to iterate through all contacts.\n"
            "Note that this callback is called when all bodies are locked, so don't use any locking functions!\n"
            "You will receive a single callback for a soft body per simulation step for performance reasons, this callback will apply to all vertices in the soft body.\n"
            "Args:\n"
            "    soft_body (Body): The soft body that collided. It is safe to access this as the soft body is only updated on the current thread.\n"
            "    manifold (SoftBodyManifold): The manifold that describes the contact surface between the two bodies. Other bodies may be modified by other threads during this callback.");
}
